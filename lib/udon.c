/*---- udon parser implementation - automatically generated by genmachine ----*/
#define _XOPEN_SOURCE 700
#define _REENTRANT

#include "udon.h"
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

int udon_global_error = UDON_OK;

/* TODO:
 *  - Ability to specify a different set of hash routines (specifically to use
 *    with other language bindings)
 */
static inline int is_prime(unsigned int n) {
    /* Rarely run, ok if slow */
    unsigned int div = 3;
    while(div * div < n && n % div != 0) div += 2;
    return n % div != 0;
}

static inline int gm_string_eq(GMString *a, GMString *b) {
    if(a==NULL || b==NULL) return 0;
    if(a->size != b->size) return 0;
    return (memcmp(a->start, b->start, a->size) == 0);
}

GmDict *gm_dict_create_standard(void) {
    GmDict *gmd = malloc(sizeof(GmDict));
    if(!gmd) return NULL; /* TODO: longjump to error */
    gmd->size = 19;
    gmd->filled = 0;
    gmd->table = (GmEntry *) calloc(gmd->size + 1, sizeof(GmEntry));
    if(!gmd->table) return NULL; /* TODO: err */
    return gmd;
}

GmDict *gm_dict_create(size_t s) {
    GmDict *gmd = malloc(sizeof(GmDict));
    if(!gmd) return NULL; /* TODO: longjump to error */
    if(s < 3) s = 3;
    s |= 1; /* ensure odd */
    while(!is_prime(s)) s += 2;
    gmd->size = s;
    gmd->filled = 0;
    gmd->table = (GmEntry *) calloc(gmd->size + 1, sizeof(GmEntry));
    if(!gmd->table) return NULL; /* TODO: err */
    return gmd;
}

void gm_dict_destroy(GmDict *gmd) {
    if(gmd == NULL) return;
    if(gmd->table == NULL) return;
    free(gmd->table);
    gmd->table = NULL;
}

/* Returns a pointer to the old value */
/* Right now doesn't replace key w/ pointer to textually identical one. Change
 * if for some reason later we need to clean up the old key or something... */
void * gm_dict_add_or_update(GmDict *gmd, GmString *key, void *new_value) {
    uint64_t idx;
    uint64_t hval = key->length;
    uint64_t count = hval;
    void *   retval;
    while(count-- > 0) {
        hval <<= 4;
        hval += key->start[count];
    }
    if(hval == 0) ++hval;

    idx = hval % gmd->size + 1; /* First simple hash function: modulus (except 0) */
    if(gmd->table[idx]._used) {
        if(gmd->table[idx]._used == hval && gm_string_eq(key,gmd->table[idx].key)) {
            retval = gmd->table[idx].value;
            gmd->table[idx].value = new_value;
            return retval;
        }
        uint64_t hval2 = 1 + hval % (gmd->size - 2);
        uint64_t first_idx = idx;
        do {
            if(idx <= hval2) idx = gdm->size + idx - hval2;
            else idx -= hval2;
            if(idx == first_idx) break;
            if(gmd->table[idx].used == hval && gm_string_eq(key, gmd->table[idx].key)) {
                retval = gmd->table[idx].value;
                gmd->table[idx].value = new_value;
                return retval;
            }
        } while(gmd->table[idx].used);
    }

    /* Not found */
    if(gmd->filled == gmd->size) {
        /* TODO: realloc (and zero out all new)*/
        return NULL;
    }
    gmd->table[idx]._used = hval;
    gmd->table[idx].key = key;
    gmd->table[idx].value = new_value;
    ++gmd->filled;
    return NULL;
}

void * gm_dict_value_for(GmDict *gmd, GmString *key) {
    uint64_t idx;
    uint64_t hval = key->length;
    uint64_t count = hval;
    void *   retval;
    while(count-- > 0) {
        hval <<= 4;
        hval += key->start[count];
    }
    if(hval == 0) ++hval;

    idx = hval % gmd->size + 1; /* First simple hash function: modulus (except 0) */
    if(gmd->table[idx]._used) {
        if(gmd->table[idx]._used == hval && gm_string_eq(key,gmd->table[idx].key)) {
            return gmd->table[idx].value;
        }
        uint64_t hval2 = 1 + hval % (gmd->size - 2);
        uint64_t first_idx = idx;
        do {
            /* Steps through all available indices because size is prime */
            if(idx <= hval2) idx = gdm->size + idx - hval2;
            else idx -= hval2;
            if(idx == first_idx) return NULL;
            if(gmd->table[idx].used == hval && gm_string_eq(key, gmd->table[idx].key)) {
                return gmd->table[idx].value;
            }
        } while(gmd->table[idx].used);
    }
    return NULL;
}



int udon_parse(UdonParseState *p) {
    int errval                   = setjmp(p->err_jmpbuf);
    if(errval) return errval;
    p->result                    = _udon_node__s_child_shortcut(p);
    return 0;
}


static inline UdonFullNode * _udon_node(UdonParseState *p) {
    UdonFullNode * self_res      = _new_udon_full_node();
    uint64_t inline              = 1;
    uint64_t ibase               = p->column;
    uint64_t ipar                = p->column-1;
    s_init:
        if(_UDON_EOF) {
            self_res.node_type   = UDON_BLANK;
            return self_res;
        } else {
          _inner_s_init:
            switch(*(p->curr)) {
                case '\n':  /*-- init.value1 ---*/
                    _UDON_ADVANCE_LINE();
                    self_res.node_type = UDON_VALUE;
                    goto s_value;
                case ' ':
                case '\t':  /*-- init.value2 ---*/
                    _UDON_ADVANCE_COL();
                    self_res.node_type = UDON_VALUE;
                    goto s_value;
                case ':':   /*-- init.attr -----*/
                    _UDON_ADVANCE_COL();
                    goto s_attribute;
                case '[':   /*-- init.id -------*/   goto s_identity__id;
                case '.':   /*-- init.class ----*/   goto s_identity__class;
                case '(':   /*-- init.delim ----*/
                    self_res.name = _udon_label__s_delim(p);
                    goto s_identity;
                case '|':   /*-- init.child ----*/   goto s_child__node;
                case '{':   /*-- init.embed ----*/   _UDON_ERR("Embedded nodes are not yet supported");
                default:    /*-- init.name -----*/
                    self_res.name = _udon_label(p);
                    goto s_identity;
            }
        }
    s_identity:
        if(_UDON_EOF) goto _eof;
        else {
          _inner_s_identity:
            switch(*(p->curr)) {
                case ' ':
                case '\t':  /*-- identity.lead -*/
                    _UDON_ADVANCE_COL();
                    goto s_identity;
                case '[':   /*-- identity.id ---*/
                  s_identity__id:
                    self_res.id  = _udon_id(p);
                    goto s_identity;
                case '.':   /*-- identity.class */
                  s_identity__class:
                    _UDON_ADVANCE_COL();
                    self_res.classes << _udon_label(p);
                    goto s_identity;
                default:    /*-- identity.child */   goto _inner_s_child;
            }
        }
    s_child_shortcut:
        self_res.node_type       = UDON_ROOT;
        goto _inner_s_child;
    s_child:
        if(_UDON_EOF) goto _eof;
        else {
          _inner_s_child:
            switch(*(p->curr)) {
                case ' ':
                case '\t':  /*-- child.lead ----*/
                    _UDON_ADVANCE_COL();
                    goto s_child;
                case '\n':  /*-- child.nl ------*/
                    if(!inline) self_res->children<<UdonNode *;
                    inline       = 0;
                    goto s_child;
                case '#':   /*-- child.comment -*/
                    _UDON_ADVANCE_COL();
                    _udon_comment(p);
                    goto s_child;
            }
        }
    s_value:
        _UDON_ERR("Parser for 'value' in 'node' not yet implemented.");
    s_attribute:
        _UDON_ERR("Parser for 'attribute' in 'node' not yet implemented.");
    s_child__node:
        _UDON_ERR("Parser for 'child' in 'node' (substate 'node') not yet implemented.");
    _eof:
        return self_res;
}


static inline UdonGmString * _udon_label(UdonParseState *p) {
    UdonGmString * self_res      = _new_udon_gm_string();
    uint64_t lvl                 = 0;
    self_res->start              = p->curr;
    s_init:
        if(_UDON_EOF) goto _eof;
        else {
          _inner_s_init:
            switch(*(p->curr)) {
                case '(':   /*-- init.delim ----*/   goto s_delim__nest;
                case ' ':
                case '\t':
                case '\n':
                case '[':
                case '|':
                case '.':
                case '!':   /*-- init.done -----*/
                    self_res->length = p->curr - self_res->start;
                    return self_res;
                default:    /*-- init.collect --*/
                    _UDON_ADVANCE_COL();
                    goto s_init;
            }
        }
    s_delim:
        if(_UDON_EOF) goto _eof;
        else {
          _inner_s_delim:
            switch(*(p->curr)) {
                case '(':   /*-- delim.nest ----*/
                  s_delim__nest:
                    _UDON_ADVANCE_COL();
                    lvl         += 1;
                    goto s_delim;
                case ')':   /*-- delim.unnest --*/
                    _UDON_ADVANCE_COL();
                    lvl         -= 1;
                    if(lvl==0) return self_res;
                    else goto s_delim;
                case '\n':  /*-- delim.collect1 */
                    _UDON_ADVANCE_LINE();
                    goto s_delim;
                default:    /*-- delim.collect2 */
                    _UDON_ADVANCE_COL();
                    goto s_delim;
            }
        }
    _eof:
        self_res->length         = p->curr - self_res->start;
        return self_res;
}


static inline UdonFullNode * _udon_node__s_child_shortcut(UdonParseState *p) {
    UdonFullNode * self_res      = _new_udon_full_node();
    uint64_t inline              = 1;
    uint64_t ibase               = p->column;
    uint64_t ipar                = p->column-1;
    s_child_shortcut:
        self_res.node_type       = UDON_ROOT;
        goto _inner_s_child;
    s_child:
        if(_UDON_EOF) goto _eof;
        else {
          _inner_s_child:
            switch(*(p->curr)) {
                case ' ':
                case '\t':  /*-- child.lead ----*/
                    _UDON_ADVANCE_COL();
                    goto s_child;
                case '\n':  /*-- child.nl ------*/
                    if(!inline) self_res->children<<UdonNode *;
                    inline       = 0;
                    goto s_child;
                case '#':   /*-- child.comment -*/
                    _UDON_ADVANCE_COL();
                    _udon_comment(p);
                    goto s_child;
            }
        }
    s_init:
        if(_UDON_EOF) {
            self_res.node_type   = UDON_BLANK;
            return self_res;
        } else {
          _inner_s_init:
            switch(*(p->curr)) {
                case '\n':  /*-- init.value1 ---*/
                    _UDON_ADVANCE_LINE();
                    self_res.node_type = UDON_VALUE;
                    goto s_value;
                case ' ':
                case '\t':  /*-- init.value2 ---*/
                    _UDON_ADVANCE_COL();
                    self_res.node_type = UDON_VALUE;
                    goto s_value;
                case ':':   /*-- init.attr -----*/
                    _UDON_ADVANCE_COL();
                    goto s_attribute;
                case '[':   /*-- init.id -------*/   goto s_identity__id;
                case '.':   /*-- init.class ----*/   goto s_identity__class;
                case '(':   /*-- init.delim ----*/
                    self_res.name = _udon_label__s_delim(p);
                    goto s_identity;
                case '|':   /*-- init.child ----*/   goto s_child__node;
                case '{':   /*-- init.embed ----*/   _UDON_ERR("Embedded nodes are not yet supported");
                default:    /*-- init.name -----*/
                    self_res.name = _udon_label(p);
                    goto s_identity;
            }
        }
    s_identity:
        if(_UDON_EOF) goto _eof;
        else {
          _inner_s_identity:
            switch(*(p->curr)) {
                case ' ':
                case '\t':  /*-- identity.lead -*/
                    _UDON_ADVANCE_COL();
                    goto s_identity;
                case '[':   /*-- identity.id ---*/
                  s_identity__id:
                    self_res.id  = _udon_id(p);
                    goto s_identity;
                case '.':   /*-- identity.class */
                  s_identity__class:
                    _UDON_ADVANCE_COL();
                    self_res.classes << _udon_label(p);
                    goto s_identity;
                default:    /*-- identity.child */   goto _inner_s_child;
            }
        }
    s_value:
        _UDON_ERR("Parser for 'value' in 'node__s_child_shortcut' not yet implemented.");
    s_attribute:
        _UDON_ERR("Parser for 'attribute' in 'node__s_child_shortcut' not yet implemented.");
    s_child__node:
        _UDON_ERR("Parser for 'child' in 'node__s_child_shortcut' (substate 'node') not yet implemented.");
}


static inline UdonGmString * _udon_label__s_delim(UdonParseState *p) {
    UdonGmString * self_res      = _new_udon_gm_string();
    uint64_t lvl                 = 0;
    self_res->start              = p->curr;
    s_delim:
        if(_UDON_EOF) goto _eof;
        else {
          _inner_s_delim:
            switch(*(p->curr)) {
                case '(':   /*-- delim.nest ----*/
                  s_delim__nest:
                    _UDON_ADVANCE_COL();
                    lvl         += 1;
                    goto s_delim;
                case ')':   /*-- delim.unnest --*/
                    _UDON_ADVANCE_COL();
                    lvl         -= 1;
                    if(lvl==0) return self_res;
                    else goto s_delim;
                case '\n':  /*-- delim.collect1 */
                    _UDON_ADVANCE_LINE();
                    goto s_delim;
                default:    /*-- delim.collect2 */
                    _UDON_ADVANCE_COL();
                    goto s_delim;
            }
        }
    s_init:
        if(_UDON_EOF) goto _eof;
        else {
          _inner_s_init:
            switch(*(p->curr)) {
                case '(':   /*-- init.delim ----*/   goto s_delim__nest;
                case ' ':
                case '\t':
                case '\n':
                case '[':
                case '|':
                case '.':
                case '!':   /*-- init.done -----*/
                    self_res->length = p->curr - self_res->start;
                    return self_res;
                default:    /*-- init.collect --*/
                    _UDON_ADVANCE_COL();
                    goto s_init;
            }
        }
    _eof:
        self_res->length         = p->curr - self_res->start;
        return self_res;
}


static inline void * _udon_id(UdonParseState *p) {
    _UDON_ERR("Parser for 'id' not yet implemented.");
    return NULL;
}


static inline void * _udon_comment(UdonParseState *p) {
    _UDON_ERR("Parser for 'comment' not yet implemented.");
    return NULL;
}


static inline UdonFullNode * _new_udon_full_node(UdonParseState *p) {
    UdonFullNode * res           = (UdonFullNode *)udon_malloc(sizeof(UdonFullNode));
    if(!res) _UDON_MEM_ERR("Memory allocation failed for FullNode.");
    return res;
}


static inline UdonGmString * _new_udon_gm_string(UdonParseState *p) {
    UdonGmString * res           = (UdonGmString *)udon_malloc(sizeof(UdonGmString));
    if(!res) _UDON_MEM_ERR("Memory allocation failed for STRING.");
    return res;
}


