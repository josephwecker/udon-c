
TODO: use machine node-name and state names in resulting structure where appropriate:
    * line | column
    * grammar_part | type | state
TODO: basic struct inheritance for fewer wasted fields.


## <struct>~    =>  <data>->first_child
## <struct>'    =>  <data>->next

<struct> << <struct> => either set first_child of left or set the tail child and advance that to tail.
@<struct>    => indicates a struct that acts across states in the same function / predefined/reserved vars
$<struct>    => global
->           => $p_curr += 1;
<-           => $p_curr -= 1;
setm         => $mark = $p_curr
endm         => *$p_curr = 0; // null-terminate it
@a           => $mark  // a for accumulator even though that's not really what we're doing...


TODO: when given [ \t] to match, strategize assuming that spaces are far more frequent.
TODO: (see N1) in this situation where we now know which character matches, possibly jump into the middle of the                next state- know which one to go to...
TODO: inline other grammar functions... probably possible (even at construction time) for all but recursive ones.
TODO: add_attr needs to handle anonymous attributes well.

+-----------------------------------+--------------------------------------------------+-----------------------+
| document()[ROOT]                  | setm;                                            | :toplevel             |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| :toplevel       | [\n]            | endm; @ch << TEXT(@a); ->;                       | :toplevel             |
| :toplevel       | [\t]            | ->;                                              | :toplevel             |
| :toplevel       | [#]             | ->; @ch << mcomment(); setm;                     | :toplevel             |
| :toplevel       | [|]             | ->; @ch << node(); setm;                         | :toplevel             |
| :toplevel       | .               | ->;                                              | :toplevel:data        |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| :toplevel:data  | [\n]            | endm; @ch << TEXT(@a); ->;                       | :toplevel             |
| :toplevel:data  | .               | ->;                                              | :toplevel:data        |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| {eof}           |                 | {@a.len}(@ch << TEXT(@a));                       | <return @s>           |
+-----------------+-----------------+--------------------------------------------------+-----------------------+


+-----------------+-----------------+--------------------------------------------------+-----------------------+
| mcomment()[COMMENT]               | ibase=$col+1; ipar=$col;                         | :first:ws             |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| :first:ws       | [ \t]           | ->;  ibase += 1;                                 | :first:ws             |
| :first:ws       | [\n]            | ->;                                              | :nextline             |
| :first:ws       | .               | setm; ->;                                        | :data                 |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| :data           | [\n]            | endm; @ch << TEXT(@a); ->;                       | :nextline             |
| :data           | .               | ->;                                              | :data                 |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| :nextline       | {$col > ibase}  | setm; ->;                                        | :data                 |
| :nextline       | [ \t]           | ->;                                              | :nextline             |
| :nextline       | [\n]            | @ch << TEXT(""); ->;                             | :nextline             |
| :nextline       | {$col <= ipar}  |                                                  | <return @s>           |
| :nextline       | .               | setm; ibase=$col; ->;                            | :data                 |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| {eof}           |                 | {@a.len}(@ch << TEXT(@a));                       | <return @s>           |
+-----------------+-----------------+--------------------------------------------------+-----------------------+


 |<name> [<id>] .<class> .<class> :<key> <value> :<key> <value>   INLINE DATA


+-----------------+-----------------+--------------------------------------------------+-----------------------+
| node()[NODE]                      | ipar=$col;                                       | :first:type           |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| :first:type     | ^[ \t\n\[.#:]   | @s.name = label_str();                           | :first:ident       | N1
| :first:type     | .               |                                                  | :first:ident          |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| :first:ident    | [ \t]           | ->;                                              | :first:ident          |
| :first:ident    | [\n]            | ->;                                              | :children             |
| :first:ident    | [\[]            | ->; @s.id = nested_str('[',']');                 | :first:ident          |
| :first:ident    | [.]             | ->; @s.append_class(label_str());                | :first:ident          |
| :first:ident    | [:]             | ->; attkey = label();                            | :first:attr:val       |
| :first:ident    | [#]             | $skip_past("\n");                                | :children             |
| :first:ident    | .               | setm; ->;                                        | :first:data           |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| :first:data     | {eof?}          | endm; @s.val = @a;                               | <return @s>           |
| :first:data     | [\n]            | endm; @s.val = @a;                               | :children             |
| :first:data     | [#]             | endm; @s.val = @a; $skip_past("\n");             | :children             |
| :first:data     | .               | ->;                                              | :first:data           |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| :first:attr:val | {eof?}          | @s.add_attr(attkey, null);                       | <return @s>           |
| :first:attr:val | [ \t]           | ->;                                              | :first:attr:val       |
| :first:attr:val | [\n]            | ->; @s.add_attr(attkey, null);                   | :children             |
| :first:attr:val | [#]             | $skip_past("\n"); @s.add_attr(attkey, null);     | :children             |
| :first:attr:val | .               | @s.add_attr(attkey, label_str());                | :first:ident          |
+-----------------+-----------------+--------------------------------------------------+-----------------------+
+-----------------+-----------------+--------------------------------------------------+-----------------------+
| {eof}           |                 |                                                  | <return @s>           |
+-----------------+-----------------+--------------------------------------------------+-----------------------+

