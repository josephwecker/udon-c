|parser udon

TODO:

 * Rules for appending string to linked list:
   - ignore/don't-append if string is NULL
   - ignore/don't-append if string's start is NULL
   - MARK_END to current position if marked flag is not yet set.
   - (have the "marked" flag a local variable instead of a member)

 - <RBR> special
 - automatically construct a new string for a variable if last one was already
   appended and new one is "MARK"ed
 - "MARKED" boolean predicate macro
 - catch this up with older udon*.machine drafts.
 - support for void functions (e.g., block_comment)
 - support for advance-past and advance-to
 - support negative advance-to character classes (e.g.  ->[^ \t])
 - optional mark_end (only if not marked) with 'MARK_END?' (?) - or possibly
   always check strings that are being appended to linked lists and mark_end
   with the current position if they aren't already.
 - adjust mark_end by some position (mark_end(-1))
 - each function also takes an optional "S" which it uses instead of creating one (see .value2)
 - make sure eof checks happen when there are no switch statements (e.g. block_comment)
 - fix genmachine typing, esp. wrt linked lists.
 - finish genmachine as per everything needed here.
 - types automatically include a member field that indicates the function that
   generated it.

|enum[NodeType]
  |ROOT |BLANK |NORMAL

|struct[Node]
  |node_type     NodeType
  |source_line   Z+
  |source_column Z+
  |name          STRING
  |id            STRING
  |classes       LIST
  |attributes    DICT
  |children      Node

|struct[Data]
  |lines         LIST

|entry-point /node:child-shortcut

#-------------+-----------+----------------------------------------+----------------
|function[node:Node]  | inl=1 | ibase=COL | ipar=COL-1 | S.node_type=NORMAL
  |state[:init]
    |eof                  | S.node_type=BLANK                      |return S
    |c[\n]    |.value1    | -> | S.node_type=BLANK                 |>> :child
    |c[ \t]   |.value2    | -> | S = /value                        |return S
    |c[:]     |.attr      | ->                                     |>> :attribute
    |c[<LBR>] |.id        |                                        |>> :identity.id
    |c[.]     |.class     |                                        |>> :identity.class
    |c[(]     |.delim     | S.name=/label:delim                    |>> :identity
    |c[<PIPE>]|.child     |                                        |>> :child2.node
    |c[{]     |.embed     |err Embedded nodes are not yet supported
    |default  |.name      | S.name=/label                          |>> :identity
  |state[:identity]
    |c[ \t]   |.lead      | ->                                     |>>
    |c[<LBR>] |.id        | S.id=/id                               |>>
    |c[.]     |.class     | ->| S.classes << /label                |>>
    |default  |.child     |                                        |>> :child
  |state[:child-shortcut] | S.node_type=ROOT | inl = 0             |>> :child
  |state[:child]
    |c[ \t]   |.lead      | ->                                     |>>
    |c[\n]    |.nl        |if[!inl] | C << /node |endif | inl=0    |>>
    |c[#]     |.bcomment  | -> | /block_comment                    |>>
    |default  |.text      |if[COL <= ipar]                         |return S
                          |endif                                   |>> :child2
  |state[:child2]
    |c[<PIPE>]|.node      | -> | C << /node                        |>> :child
    |c[:]     |.attribute | ->                                     |>> :attribute
    |default  |.value     |if[inl] | C << /value                   |>> :child
                          |endif   | C << /data                    |>> :child
  |state[:attribute]
    |c[<PIPE>]|.grim      | -> | g=/node | S.attributes[g.name]=g  |>> :child
    |c[<LBR>] |.grim2     |    | g=/node | S.attributes[g.name]=g  |>> :child
    |default  |.normal    | key=/label | S.attributes[key]=/value  |>> :child

#-------------+-----------+----------------------------------------+----------------
|function[value:Data]     | ibase = COL | ipar=COL-1 | a=STRING | MARK(a)
  |eof                    | S.lines << a                           |return S
  |state[:main]
    |c[ \t]   |.space     | MARK_END(a) | ->                       |>> :disamb
    |c[\n]    |.newline   | MARK_END(a) | ->                       |>> :newline
    |default  |.collect   | ->                                     |>>
  |state[:disamb]
    |c[ \t]   |.space     | ->                                     |>>
    |c[\n]    |.newline   | ->                                     |>> :newline
    |c[#]     |.comment   | [\n]->                                 |>> :newline
    |c[<PIPE>.!:] |.done  | S.lines << a                           |return S
    |default  |.collect   | ->                                     |>> :main
  |state[:newline]        | S.lines << a
  |state[:linestart]
    |if[COL > ibase]      | a = STRING | MARK(a)                   |>> :main
    |c[ \t]   |.indent    | ->                                     |>>
    |c[\n]    |.newline   | ->                                     |>>
    |c[#]     |.comment   | [\n]->                                 |>>
    |default  |.value
      |if[COL <= ipar]                                             |return S
      |else               | a = STRING | MARK(a)                   |>> :main

#-------------+-----------+----------------------------------------+----------------
|function[data:Data]      | ibase = COL | ipar=COL-1 | a=STRING | MARK(a)
  |eof                    | S.lines << a                           |return S
  |state[:main]           | ->[\n] | MARK_END(a) | S.lines<<a | ->
  |state[:newline]
    |if[COL > ibase]      | a=STRING | MARK(a)                     |>> :main
    |c[ \t]   |.indent    | ->                                     |>>
    |c[\n]    |.newline   | ->                                     |>>
    |default  |.value
      |if[COL <= ipar]                                             |return S
      |else               | a=STRING | MARK(a)                     |>> :main

#-------------+-----------+----------------------------------------+----------------
|function[label:STRING]   | lvl=0 | MARK
  |eof                    | MARK_END                               |return S
  |state[:init]
    |c[(]     |.delim     |                                        |>> :delim.nest
    |c[ \t\n<LBR><PIPE>.!]|.done| MARK_END                         |return S
    |default  |.collect   | ->                                     |>>
  |state[:delim]
    |eof      |err Unexpected end of file - missing closing ')'
    |c[(]     |.nest      | -> | lvl+=1                            |>>
    |c[)]     |.unnest    | -> | lvl-=1
      |if[lvl==0]         | MARK_END                               |return S
      |else                                                        |>>
    |c[\n]    |.collect1  | ->                                     |>>
    |default  |.collect2  | ->                                     |>>

#-------------+-----------+----------------------------------------+----------------
|function[id:STRING]      | lvl=0 | MARK
  |eof        |err Unexpected end of file - missing closing ']'
  |state[:delim]
    |c[<LBR>] |.nest      | -> | lvl += 1                          |>>
    |c[<RBR>] |.unnest    | -> | lvl -= 1
      |if[lvl==0]         | MARK_END                               |return S
      |else                                                        |>>
    |c[\n]    |.collectnl | ->                                     |>>
    |default  |.collect   | ->                                     |>>

#-------------+-----------+----------------------------------------+----------------
|function[block_comment]  | ibase = COL | ipar = COL - 1
  |state[:main]           | [\n]->                                 |>> :next
  |state[:next]           | ->[^ \t]
    |if[COL <= ipar]                                               |return
    |else                                                          |>> :main
