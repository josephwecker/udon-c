|parser udon

|enum[NodeType]
  |ROOT |BLANK |VALUE |FULL

|struct[Node < LIST]
  |node_type     NodeType
  |source_line   Z+
  |source_column Z+

|struct[FullNode < Node]
  |children      Node
  |name          STRING
  |id            STRING
  |classes       LIST
  |attributes    DICT

|entry-point /node:child-shortcut

|function[node:FullNode]  | inl=1 | ibase=COL | ipar=COL-1
  |state[:init]
    |eof                  | ((UdonNode *)S).node_type=BLANK                      |return S
    |c[\n]    |.value1    | -> | ((UdonNode *)S).node_type=VALUE                 |>> :value
    |c[ \t]   |.value2    | -> | ((UdonNode *)S).node_type=VALUE                 |>> :value
    |c[:]     |.attr      | ->                                     |>> :attribute
    |c[<LBR>] |.id        |                                        |>> :identity.id
    |c[.]     |.class     |                                        |>> :identity.class
    |c[(]     |.delim     | S.name=/label:delim                    |>> :identity
    |c[<PIPE>]|.child     |                                        |>> :child.node
    |c[{]     |.embed     |err Embedded nodes are not yet supported
    |default  |.name      | S.name=/label                          |>> :identity
  |state[:identity]
    |c[ \t]   |.lead      | ->                                     |>>
    |c[<LBR>] |.id        | S.id=/id                               |>>
    |c[.]     |.class     | ->| S.classes<</label                  |>>
    |default  |.child     |                                        |>> :child
  |state[:child-shortcut] | ((UdonNode *)S).node_type=ROOT                       |>> :child
  |state[:child]
    |c[ \t]   |.lead      | ->                                     |>>
    |c[\n]    |.nl        |if[!inl] | C<<Node |endif | inl=0       |>>
    |c[#]     |.comment   | -> | /comment                          |>>
# TODO: comment does advanced skipping


|function[label:STRING]   | lvl=0 | MARK
  |eof                    | MARK_END                               |return S
  |state[:init]
    |c[(]     |.delim     |                                        |>> :delim.nest
    |c[ \t\n<LBR><PIPE>.!]|.done| MARK_END                         |return S
    |default  |.collect   | ->                                     |>>
  |state[:delim]
    #|eof      |err Unexpected end of file - missing closing ')'
    |c[(]     |.nest      | -> | lvl+=1                            |>>
    |c[)]     |.unnest    | -> | lvl-=1
      |if[lvl==0]                                                  |return S
      |else                                                        |>>
      |endif
    |c[\n]    |.collect1  | ->                                     |>>
    |default  |.collect2  | ->                                     |>>
