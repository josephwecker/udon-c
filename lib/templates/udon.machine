|parser udon

TODO:
 - quick syntax highlight for new genmachine syntax.
 - catch this up with older udon*.machine drafts.
 - fix genmachine typing, esp. wrt linked lists.
 - finish genmachine as per everything needed here.

|enum[NodeType]
  |ROOT |BLANK |VALUE |FULL

|struct[Node]
  |node_type     NodeType
  |source_line   Z+
  |source_column Z+
  |name          STRING
  |id            STRING
  |value         STRING
  |classes       LIST
  |attributes    DICT
  |children      Node

|entry-point /node:child-shortcut

|function[node:Node]  | inl=1 | ibase=COL | ipar=COL-1
  |state[:init]
    |eof                  | S.node_type=BLANK                      |return S
    |c[\n]    |.value1    | -> | S.node_type=BLANK                 |>> :child
    |c[ \t]   |.value2    | -> | S = /value_node                   |return S
                          # TODO: free old S
    |c[:]     |.attr      | ->                                     |>> :attribute
    |c[<LBR>] |.id        |                                        |>> :identity.id
    |c[.]     |.class     |                                        |>> :identity.class
    |c[(]     |.delim     | S.name=/label:delim                    |>> :identity
    |c[<PIPE>]|.child     |                                        |>> :child2.node
    |c[{]     |.embed     |err Embedded nodes are not yet supported
    |default  |.name      | S.name=/label                          |>> :identity
  |state[:identity]
    |c[ \t]   |.lead      | ->                                     |>>
    |c[<LBR>] |.id        | S.id=/id                               |>>
    |c[.]     |.class     | ->| S.classes << /label                |>>
    |default  |.child     |                                        |>> :child
  |state[:child-shortcut] | S.node_type=ROOT | inl = 0             |>> :child
  |state[:child]
    |c[ \t]   |.lead      | ->                                     |>>
    |c[\n]    |.nl        |if[!inl] | C << /node |endif | inl=0    |>>
    |c[#]     |.comment   | -> | /comment                          |>>
    |default  |.text      |if[COL <= ipar]                         |return S
                          |endif                                   |>> :child2
  |state[:child2]
    |c[<PIPE>]|.node      | -> | C << /node                        |>> :child
    |c[:]     |.attribute | ->                                     |>> :attribute
    |default  |.value     |if[inl] | C << /value_node              |>> :child
                          |endif   | C << /data_node               |>> :child

|function[value:STRING]   | ibase = COL | ipar = COL - 1 | MARK
  |state[:main]           | S.node_type = VALUE
    |c[ \t]   |.space     | ->                                     |
#TODO: You are here...

|function[label:STRING]   | lvl=0 | MARK
  |eof                    | MARK_END                               |return S
  |state[:init]
    |c[(]     |.delim     |                                        |>> :delim.nest
    |c[ \t\n<LBR><PIPE>.!]|.done| MARK_END                         |return S
    |default  |.collect   | ->                                     |>>
  |state[:delim]
    |eof      |err Unexpected end of file - missing closing ')'
    |c[(]     |.nest      | -> | lvl+=1                            |>>
    |c[)]     |.unnest    | -> | lvl-=1
      |if[lvl==0]                                                  |return S
      |else                                                        |>>
      |endif
    |c[\n]    |.collect1  | ->                                     |>>
    |default  |.collect2  | ->                                     |>>

|function[comment]        | ibase = COL | ipar = COL - 1
