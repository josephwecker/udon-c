|parser udon

|enum[NodeType]
  |ROOT |BLANK |VALUE |FULL

|struct[Node < LIST]
  |node_type     NodeType
  |source_line   Z+
  |source_column Z+

#|struct[Attributes]
#  |keys          LIST
#  |hash_table    struct hsearch_data *
#  |size          Z+
#  |num_allocated Z+

|struct[FullNode < Node]
  |children      Node *
  |name          STRING
  |id            STRING
  |classes       LIST
  |attributes    DICT



|entry-point /node:child-shortcut

|function[node:FullNode]  | inline=1 | ibase=COL | ipar=COL-1
  |state[:init]
    #|eof                  | S.node_type=BLANK                      |return S
    |c[\n]    |.value1    | -> | S.node_type=VALUE                 |>> :value
    |c[ \t]   |.value2    | -> | S.node_type=VALUE                 |>> :value
    |c[:]     |.attr      | ->                                     |>> :attribute
    |c[<LBR>] |.id        |                                        |>> :identity.id
    |c[.]     |.class     |                                        |>> :identity.class
    |c[(]     |.delim     | S.name=/label:delim                    |>> :identity
    |c[<PIPE>]|.child     |                                        |>> :child.node
    |c[{]     |.embed     |err Embedded nodes are not yet supported
    |default  |.name      | S.name=/label                          |>> :identity
  |state[:identity]
    #|eof                  |                                        |return S
    |c[ \t]   |.lead      | ->                                     |>>
    |c[<LBR>] |.id        | S.id=/id                               |>>
    |c[.]     |.class     | ->| S.classes<</label                  |>>
    |default  |.child     |                                        |>> :child
  |state[:child-shortcut] | S.node_type=ROOT                       |>> :child
  |state[:child]
    |c[ \t]   |.lead      | ->                                     |>>
    |c[\n]    |.nl        |if[!inline] | C<<Node |endif | inline=0 |>>
    |c[#]     |.comment   | -> | /comment                          |>>
# TODO: comment does advanced skipping


|function[label:STRING]   | lvl=0
  |state[:init]           | MARK
    |c[(]     |.delim     |                                        |>> :delim.nest
    |c[ \t\n<LBR><PIPE>.!]|.done| MARK_END                         |return S
    |default  |.collect   | ->                                     |>>
  |state[:delim]
    #|eof      |err Unexpected end of file - missing closing ')'
    |c[(]     |.nest      | -> | lvl+=1                            |>>
    |c[)]     |.unnest    | -> | lvl-=1
      |if[lvl==0]                                                  |return S
      |else                                                        |>>
      |endif
    |c[\n]    |.collect1  | ->                                     |>>
    |default  |.collect2  | ->                                     |>>
  |state[eof]             | MARK_END                               |return S



# C shorthands TODO:
  * Prefix main types
  * Use _base for inheritance
  * LIST   -> GenMachineLL
  * Z+     -> uint64_t
  * STRING -> char * (maybe in the future w_char?) _and_ separate length
  * For anything that is LIST or that has an append operator on it, another
    field to hold the head (or tail, whichever way it's implemented).
  * For structs, create the prefix_new_... functions


