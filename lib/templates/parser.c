/*---- {{parser}} parser implementation - automatically generated by genmachine ----*/


/*----------------- PRIVATE HEADER ---------------------*/
#define _XOPEN_SOURCE 700
#define _REENTRANT

#include "{{parser}}.h"
#include <stddef.h>
#include <stdlib.h>
#include <setjmp.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <err.h>
{% if use_gmdict %}#include <string.h>{% endif %}

#define _{{parser|up}}_EOF p->curr == p->end

int {{parser}}_global_error = {{parser|up}}_OK;
char {{parser}}_global_error_msg[128];

{% if use_gmdict %}/* --- Dict --- */
struct {{parser|cap}}DictEntry {
    {{parser|cap}}String *key;
    void *value;
    unsigned int used;
};
typedef struct {{parser|cap}}DictEntry {{parser|cap}}DictEntry;

struct {{parser|cap}}Dict {
    {{parser|cap}}DictEntry *table;
    uint64_t size;
    uint64_t num_allocated;
    {{parser|cap}}List *keys;
    {{parser|cap}}List *_keys__tail;
};
{% endif %}

/* --- ParseState --- */
struct _{{parser|cap}}ParseState {
    {{parser|cap}}ParseState _public;
    jmp_buf          err_jmpbuf; /* Where to go on error. */

    uint64_t         line;
    uint64_t         column;

    char             *curr;
    uint64_t         *qcurr;
    char             *end;
    uint64_t         *qend;
    size_t           qsize;     /* Automatically calculated, for quickscans. */
    char             *alpha;    /* Used for accumulating. possibly depricated... */
};

/* --- Private prototypes --- */
{% for p in priv_protos %}
{{p}}{% endfor %}


/*----------------- IMPLEMENTATION ---------------------*/

// TODO:
//  * ParseState --> _ParseState public function
//  * Alternate hash routines for language bindings (e.g., natively create ruby
//    hashes immediately, etc.)

inline {{parser|cap}}ParseState *{{parser}}_state(_{{parser|cap}}ParseState *p) { return &(p->_public); }

_{{parser|cap}}ParseState *{{parser}}_init_from_file(char *filename) {
    size_t  bytes_read;
    int     fd;
    struct  stat statbuf;
    _{{parser|cap}}ParseState *state;

    if( (state = (_{{parser|cap}}ParseState *) udon_malloc(sizeof(_{{parser|cap}}ParseState))) == NULL)
        err({{parser|up}}_MEMORY_ERR, "Couldn't allocate memory for parser state.");
    if( (fd = open(filename, O_RDONLY)) < 0)
        err({{parser|up}}_FILE_OPEN_ERR, "Couldn't open %s.", filename);

    if( fstat(fd, &statbuf) == -1)
        err({{parser|up}}_FILE_OPEN_ERR, "Opened, but couldn't stat %s.", filename);

    state->_public.source_size = statbuf.st_size;
    state->qsize    = state->_public.source_size >> 3; // size in uint64_t chunks
    state->_public.source_origin = filename;

    // padding to the right so that quickscan stuff can look in bigger chunks
    if( (state->_public.source_buffer = (char *) udon_malloc(state->_public.source_size+8)) == NULL)
        err({{parser|up}}_MEMORY_ERR, "Couldn't allocate memory for file contents (%s).", filename);

    if( (bytes_read = read(fd, state->_public.source_buffer, state->_public.source_size)) != state->_public.source_size)
        err({{parser|up}}_FILE_READ_ERR, "Only read %zd of %zd bytes from %s.", bytes_read, state->_public.source_size, filename);

    reset_state(state);
    state->end    = &(state->_public.source_buffer[state->_public.source_size - 1]);
    state->qend   = &(state->qcurr[state->qsize - 1]);
    state->curr[state->_public.source_size] = 0; // Null terminate the whole thing just in case
    close(fd);
    return state;
}

{% if use_gmdict %}/* --- Dict generic code --- */
static inline int is_prime(unsigned int n) {
    /* Rarely run, ok if slow */
    unsigned int div = 3;
    while(div * div < n && n % div != 0) div += 2;
    return n % div != 0;
}

static inline int string_eq({{parser|cap}}String *a, {{parser|cap}}String *b) {
    if(a==NULL || b==NULL) return 0;
    if(a->length != b->length) return 0;
    return (memcmp(a->start, b->start, a->length) == 0);
}

{{parser|cap}}Dict *{{parser}}_dict_create(void) {
    {{parser|cap}}Dict *dict = malloc(sizeof({{parser|cap}}Dict));
    if(!dict) return NULL;
    dict->num_allocated = 19;
    dict->size = 0;
    dict->table = ({{parser|cap}}DictEntry *) calloc(dict->num_allocated + 1, sizeof({{parser|cap}}DictEntry));
    if(!dict->table) return NULL;
    return dict;
}

{{parser|cap}}Dict *{{parser}}_dict_create_sized(size_t s) {
    {{parser|cap}}Dict *dict = malloc(sizeof({{parser|cap}}Dict));
    if(!dict) return NULL;
    if(s < 3) s = 3;
    s |= 1; /* ensure odd */
    while(!is_prime(s)) s += 2;
    dict->num_allocated = s;
    dict->size = 0;
    dict->table = ({{parser|cap}}DictEntry *) calloc(dict->num_allocated + 1, sizeof({{parser|cap}}DictEntry));
    if(!dict->table) return NULL;
    return dict;
}

void {{parser}}_dict_destroy({{parser|cap}}Dict *dict) {
    if(dict == NULL) return;
    if(dict->table == NULL) return;
    free(dict->table);
    dict->table = NULL;
}

/* Returns a pointer to the old value */
/* Right now doesn't replace key w/ pointer to textually identical one. Change
 * if for some reason later we need to clean up the old key or something... */
void * {{parser}}_dict_add_or_update({{parser|cap}}Dict *dict, {{parser|cap}}String *key, void *new_value) {
    uint64_t idx;
    uint64_t hval = key->length;
    uint64_t count = hval;
    void *   retval;
    while(count-- > 0) {
        hval <<= 4;
        hval += key->start[count];
    }
    if(hval == 0) ++hval;

    idx = hval % dict->num_allocated + 1; /* First simple hash function: modulus (except 0) */
    if(dict->table[idx].used) {
        if(dict->table[idx].used == hval && string_eq(key,dict->table[idx].key)) {
            retval = dict->table[idx].value;
            dict->table[idx].value = new_value;
            return retval;
        }
        uint64_t hval2 = 1 + hval % (dict->num_allocated - 2);
        uint64_t first_idx = idx;
        do {
            if(idx <= hval2) idx = dict->num_allocated + idx - hval2;
            else idx -= hval2;
            if(idx == first_idx) break;
            if(dict->table[idx].used == hval && string_eq(key, dict->table[idx].key)) {
                retval = dict->table[idx].value;
                dict->table[idx].value = new_value;
                return retval;
            }
        } while(dict->table[idx].used);
    }

    /* Not found */
    if(dict->size == dict->num_allocated) {
        /* TODO: realloc (and zero out all new)*/
        return NULL;
    }
    dict->table[idx].used = hval;
    dict->table[idx].key = key;
    dict->table[idx].value = new_value;
    ++dict->size;
    return NULL;
}

void * {{parser}}_dict_value_for({{parser|cap}}Dict *dict, {{parser|cap}}String *key) {
    uint64_t idx;
    uint64_t hval = key->length;
    uint64_t count = hval;
    void *   retval;
    while(count-- > 0) {
        hval <<= 4;
        hval += key->start[count];
    }
    if(hval == 0) ++hval;

    idx = hval % dict->num_allocated + 1; /* First simple hash function: modulus (except 0) */
    if(dict->table[idx].used) {
        if(dict->table[idx].used == hval && string_eq(key,dict->table[idx].key)) {
            return dict->table[idx].value;
        }
        uint64_t hval2 = 1 + hval % (dict->num_allocated - 2);
        uint64_t first_idx = idx;
        do {
            /* Steps through all available indices because size is prime */
            if(idx <= hval2) idx = dict->num_allocated + idx - hval2;
            else idx -= hval2;
            if(idx == first_idx) return NULL;
            if(dict->table[idx].used == hval && string_eq(key, dict->table[idx].key)) {
                return dict->table[idx].value;
            }
        } while(dict->table[idx].used);
    }
    return NULL;
}
{% endif %}

{% for f in functions %}
{{f}}
{% endfor %}
